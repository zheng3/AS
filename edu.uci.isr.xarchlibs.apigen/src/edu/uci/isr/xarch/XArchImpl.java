/*
 * Copyright (c) 2000-2005 Regents of the University of California.
 * All rights reserved.
 *
 * This software was developed at the University of California, Irvine.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Irvine.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */
package edu.uci.isr.xarch;

import org.w3c.dom.*;

import edu.uci.isr.xarch.*;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

import java.util.*;

/**
 * DOM-Based implementation of the IXArch interface.
 *
 * @author Automatically generated by xArch apigen.
 */
public class XArchImpl implements IXArch, DOMBased, IXArchElement{
	
	public static final String XSD_TYPE_NSURI = "http://www.ics.uci.edu/pub/arch/xArch/instance.xsd";
	public static final String XSD_TYPE_NAME = "xArch";

	protected Element elt;

	private static SequenceOrder seqOrd = new SequenceOrder(
		new QName[]{
		}
	);
	
	private static String capFirstLetter(String s){
		if(s == null) return null;
		if(s.equals("")) return "";
		StringBuffer sb = new StringBuffer();
		sb.append(Character.toUpperCase(s.charAt(0)));
		if(s.length() > 0){
			sb.append(s.substring(1));
		}
		return sb.toString();
	}

	private static String uncapFirstLetter(String s){
		if(s == null) return null;
		if(s.equals("")) return "";
		StringBuffer sb = new StringBuffer();
		sb.append(Character.toLowerCase(s.charAt(0)));
		if(s.length() > 0){
			sb.append(s.substring(1));
		}
		return sb.toString();
	}

	public XArchImpl(Document doc){
		if(doc == null){
			throw new IllegalArgumentException("Document cannot be null.");
		}
		this.elt = doc.getDocumentElement();
		//DOMUtils.addXSIType(this.elt, InstanceConstants.NS_URI, XSD_TYPE_NAME);
	}

	private XArchImpl(Element elt){
		if(elt == null){
			throw new IllegalArgumentException("Element cannot be null");
		}
		this.elt = elt;
	}

	public Node getDOMNode(){
		return elt;
	}

	public void setXArch(IXArch xArch){
	}

	public IXArch getXArch(){
		return this;
	}	

	public void setDOMNode(Node node){
		if(node.getNodeType() != Node.ELEMENT_NODE){
			throw new IllegalArgumentException("Base DOM node of this type must be an Element.");
		}
		elt = (Element)node;
	}
	
	protected static SequenceOrder getSequenceOrder(){
		return seqOrd;
	}
	
	//Override 'equals' to be DOM-based...	
	public boolean equals(Object o){
		if(o == null){
			return false;
		}
		if(!(o instanceof DOMBased)){
			return super.equals(o);
		}
		DOMBased db = (DOMBased)o;
		Node dbNode = db.getDOMNode();
		return dbNode.equals(getDOMNode());
	}

	//Override 'hashCode' to be based on the underlying node
	public int hashCode(){
		return getDOMNode().hashCode();
	}

	public IXArchElement cloneElement(int depth){
		Document doc = elt.getOwnerDocument();
		if(depth == 0){
			Element cloneElt = (Element)elt.cloneNode(false);
			cloneElt = (Element)doc.importNode(cloneElt, true);
			XArchImpl cloneImpl = new XArchImpl(cloneElt);
			cloneImpl.setXArch(getXArch());
			return cloneImpl;
		}
		else if(depth == 1){
			Element cloneElt = (Element)elt.cloneNode(false);
			cloneElt = (Element)doc.importNode(cloneElt, true);
			XArchImpl cloneImpl = new XArchImpl(cloneElt);
			cloneImpl.setXArch(getXArch());
			
			NodeList nl = elt.getChildNodes();
			int size = nl.getLength();
			for(int i = 0; i < size; i++){
				Node n = nl.item(i);
				Node cloneNode = (Node)n.cloneNode(false);
				cloneNode = doc.importNode(cloneNode, true);
				cloneElt.appendChild(cloneNode);
			}
			return cloneImpl;
		}
		else /* depth = infinity */{
			Element cloneElt = (Element)elt.cloneNode(true);
			cloneElt = (Element)doc.importNode(cloneElt, true);
			XArchImpl cloneImpl = new XArchImpl(cloneElt);
			cloneImpl.setXArch(getXArch());
			return cloneImpl;
		}
	}

	/**
	 * For internal use only.
	 */
	private static Object makeWrapper(Element elt){
		QName typeName = XArchUtils.getXSIType(elt);
		if(typeName == null){
			return null;
		}
		else{
			try{
				String packageTitle = XArchUtils.getPackageTitle(typeName.getNamespaceURI());
				String packageName = XArchUtils.getPackageName(packageTitle);
				String implName = XArchUtils.getImplName(packageName, typeName.getName());
				Class c = Class.forName(implName);
				java.lang.reflect.Constructor con = c.getConstructor(new Class[]{Element.class});
				Object o = con.newInstance(new Object[]{elt});
				return o;
			}
			catch(Exception e){
				//Lots of bad things could happen, but this
				//is OK, because this is best-effort anyway.
			}
			return null;
		}
	}

	public void addObject(Object object){
		if(!(object instanceof DOMBased)){
			throw new IllegalArgumentException("Cannot handle non-DOM-based xArch entities.");
		}
		elt.appendChild(((DOMBased)object).getDOMNode());
		DOMUtils.order(elt, getSequenceOrder());

		String name = "xArch";
		if(object instanceof DOMBased){
			Node n = ((DOMBased)object).getDOMNode();
			String nodeName = n.getNodeName();
			if(nodeName != null){
				name = DOMUtils.stripPrefix(nodeName);
			}
		}

		this.fireXArchEvent(
			new XArchEvent(this, 
			XArchEvent.ADD_EVENT,
			XArchEvent.ELEMENT_CHANGED,
			name, object,
			true)
		);
	}
		
	public void addObjects(Collection objects){
		for(Iterator en = objects.iterator(); en.hasNext(); ){
			Object elt = (Object)en.next();
			addObject(elt);
		}
	}		
		
	public void clearObjects(){
		/*
		NodeList nl = elt.getChildNodes();
		for(int i = nl.getLength(); i >= 0; i++){
			Node n = nl.item(i);
			elt.removeChild(n);
		}
		*/
		Collection coll = getAllObjects();
		removeObjects(coll);
	}
		
	public void removeObject(Object object){
		if(!(object instanceof DOMBased)){
			throw new IllegalArgumentException("Cannot handle non-DOM-based xArch entities.");
		}
		//NodeList nl = DOMUtils.getChildren(elt, InstanceConstants.NS_URI, OBJECT_ELT_NAME);
		NodeList nl = elt.getChildNodes();
		for(int i = 0; i < nl.getLength(); i++){
			Node n = nl.item(i);
			if(n == ((DOMBased)object).getDOMNode()){
				elt.removeChild(n);
				
				String name = "xArch";
				if(object instanceof DOMBased){
					Node nodeForName = ((DOMBased)object).getDOMNode();
					String nodeName = nodeForName.getNodeName();
					if(nodeName != null){
						name = DOMUtils.stripPrefix(nodeName);
					}
				}
		
				this.fireXArchEvent(
					new XArchEvent(this, 
					XArchEvent.REMOVE_EVENT,
					XArchEvent.ELEMENT_CHANGED,
					name, object,
					true)
				);
				
				return;
			}
		}
	}
	
	public void removeObjects(Collection objects){
		for(Iterator en = objects.iterator(); en.hasNext(); ){
			Object elt = (Object)en.next();
			removeObject(elt);
		}
	}

	public Collection getAllObjects(){
		Vector v = new Vector();
		//NodeList nl = DOMUtils.getChildren(elt, InstanceConstants.NS_URI, OBJECT_ELT_NAME);
		NodeList nl = elt.getChildNodes();
		for(int i = 0; i < nl.getLength(); i++){
			if(nl.item(i).getNodeType() == Node.ELEMENT_NODE){
				Element el = (Element)nl.item(i);
				Object o = makeWrapper(el);

				if(o != null){
					try{
						((edu.uci.isr.xarch.IXArchElement)o).setXArch(getXArch());
						v.addElement(o);
					}
					catch(Exception e){
						v.addElement(el);
					}
				}
				else{
					v.addElement(el);
				}
			}
		}
		return v;
	}

	public boolean hasObject(Object object){
		Collection c = getAllObjects();
		
		for(Iterator en = c.iterator(); en.hasNext(); ){
			Object elt = (Object)en.next();
			if(elt.equals(object)){
				return true;
			}
		}
		return false;
	}
	
	public Collection hasObjects(Collection objects){
		Vector v = new Vector();
		for(Iterator en = objects.iterator(); en.hasNext(); ){
			Object elt = (Object)en.next();
			v.addElement(new Boolean(hasObject(elt)));
		}
		return v;
	}
		
	public boolean hasAllObjects(Collection objects){
		for(Iterator en = objects.iterator(); en.hasNext(); ){
			Object elt = (Object)en.next();
			if(!hasObject(elt)){
				return false;
			}
		}
		return true;
	}
	
	public boolean isEquivalent(IXArch objectCollection){
		if(hasAllObjects(objectCollection.getAllObjects())){
			if(objectCollection.hasAllObjects(getAllObjects())){
				return true;
			}
		}
		return false;
	}

	protected Vector xArchListeners = new Vector();

	public void addXArchListener(XArchListener l){
		if(!xArchListeners.contains(l)){
			xArchListeners.addElement(l);
		}
	}

	public void removeXArchListener(XArchListener l){
		xArchListeners.removeElement(l);
	}

	public void fireXArchEvent(XArchEvent evt){
		for(Enumeration en = xArchListeners.elements(); en.hasMoreElements(); ){
			((XArchListener)en.nextElement()).handleXArchEvent(evt);
		}
	}

	private String[] tokenizeSchemaLocations(){
		String currentSchemaLocations = elt.getAttributeNS(
			XArchConstants.XSI_NS_URI, XArchConstants.SCHEMA_LOCATION_ATTR_NAME);
		if(currentSchemaLocations == null){
			return new String[]{};
		}
		Vector v = new Vector();
		for(StringTokenizer st = new StringTokenizer(currentSchemaLocations); st.hasMoreTokens(); ){
			String nextToken = st.nextToken();
			v.addElement(nextToken);
		}
		String[] ret = new String[v.size()];
		v.copyInto(ret);
		return ret;
	}

	private void setSchemaLocations(String[] tokens){
		StringBuffer sb = new StringBuffer();
		for(int i = 0; i < tokens.length; i++){
			sb.append(tokens[i]);
			if(i != (tokens.length - 1)){
				sb.append(' ');
			}
		}
		elt.setAttributeNS(XArchConstants.XSI_NS_URI, 
			"xsi:" + XArchConstants.SCHEMA_LOCATION_ATTR_NAME, sb.toString());
	}


	public void addSchemaLocation(String uri, String location){
		String[] tokens = tokenizeSchemaLocations();
		if((tokens.length > 0) && ((tokens.length % 2) == 1)){
			throw new IllegalArgumentException("schemaLocation cannot have an odd number of tokens.");
		}
		for(int i = 0; i < tokens.length; i+=2){
			String thisUri = tokens[i];
			String thisLocation = tokens[i+1];
			if(thisUri.equals(uri)){
				tokens[i] = uri;
				tokens[i+1] = location;
				setSchemaLocations(tokens);
				return;
			}
		}
		//Didn't find it to replace, so let's add it at the end.
		String[] newTokens = new String[tokens.length + 2];
		System.arraycopy(tokens, 0, newTokens, 2, tokens.length);
		newTokens[0] = uri;
		newTokens[1] = location;
		setSchemaLocations(newTokens);
	}

	public void removeSchemaLocation(String uri){
		String[] tokens = tokenizeSchemaLocations();
		if((tokens.length > 0) && ((tokens.length % 2) == 1)){
			throw new IllegalArgumentException("schemaLocation cannot have an odd number of tokens.");
		}
		Vector v = new Vector();
		for(int i = 0; i < tokens.length; i+=2){
			String thisUri = tokens[i];
			String thisLocation = tokens[i+1];
			if(!thisUri.equals(uri)){
				v.addElement(thisUri);
				v.addElement(thisLocation);
			}
		}
		if(v.size() == tokens.length){
			return;
		}
		String[] newTokens = new String[v.size()];
		v.copyInto(newTokens);
		setSchemaLocations(newTokens);
	}

	public XArchTypeMetadata getTypeMetadata(){
		return IXArch.TYPE_METADATA;
	}
	
	public XArchInstanceMetadata getInstanceMetadata(){
		return new XArchInstanceMetadata(null);
	}

	//----------Wrapper Cache Functions

	protected HashMap wrapperCache = new HashMap();	

	public void cacheWrapper(Node domNode, IXArchElement wrapper){
		wrapperCache.put(domNode, wrapper);
	}

	public IXArchElement getWrapper(Node domNode){
		return (IXArchElement)wrapperCache.get(domNode);
	}

}