package edu.uci.isr.archstudio4.comp.booleannotation;


/* Generated By:JJTree: Do not edit this line. BPAndNode.java */

import edu.uci.isr.xarchflat.ObjRef;
import edu.uci.isr.xarchflat.XArchFlatInterface;

/**
 * Logical AND expression.
 *
 * @author Rob Egelink (egelink@ics.uci.edu)
 */
public class BPAndNode extends SimpleNode
{

    public BPAndNode( int id )
    {
        super( id );
    }

    public BPAndNode( Boolean p, int id )
    {
        super( p, id );
    }

    /**
     * Returns the AND expression stored in an object of type
     * BooleanExp.
     * @param context A boolguard context.
     * @param xarch An XArchADT proxy.
     * @return AND expression
     */
    public ObjRef toXArch( ObjRef context, XArchFlatInterface xarch )
    {
        // Create the first part of the tree (Note: An AND Node always has
        // at least two children, otherwise the node was not made.)

        ObjRef and = xarch.create( context, "And" );
	ObjRef leftChild = ( (SimpleNode)jjtGetChild( 0 ) ).toXArch( context, xarch );
	ObjRef rightChild = ( (SimpleNode)jjtGetChild( 1 ) ).toXArch( context, xarch );
        xarch.set( and, "BooleanExp1", leftChild );
        xarch.set( and, "BooleanExp2", rightChild );

        // Insert the remaining (if any) children in the tree.
        for ( int i = 2; i < jjtGetNumChildren(); ++i )
        {
            ObjRef leftOperand = xarch.create( context, "BooleanExp" );
            xarch.set( leftOperand, "And", and );

            ObjRef rightOperand = ( (SimpleNode)jjtGetChild( i ) ).toXArch( context, xarch );

            ObjRef newAnd = xarch.create( context, "And" );
            xarch.set( newAnd, "BooleanExp1", leftOperand );
            xarch.set( newAnd, "BooleanExp2", rightOperand );

            and = newAnd;
        }

        ObjRef boolexp = xarch.create( context, "BooleanExp" );
        xarch.set( boolexp, "And", and );

        return boolexp;
    }


    /**
     * Returns a human readable representation of the expression stored
     * in a AND node.
     * @return AND expression.
     */
    public String toString()
    {
        StringBuffer s = new StringBuffer( new String( "(" ) );

        for ( int i = 0; i < jjtGetNumChildren() - 1; ++i )
        {
            s.append( ( ( SimpleNode ) jjtGetChild( i ) ).toString() + " && " );
        }

        s.append( ( ( SimpleNode ) jjtGetChild( jjtGetNumChildren() - 1 ) ).toString() + ")" );

        return s.toString();
    }

}
